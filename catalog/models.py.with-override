import uuid
from django import forms
from django.db import models
from django.db.models.signals import m2m_changed
from django.utils.translation import ugettext_lazy as _

from easy_thumbnails.fields import ThumbnailerImageField

from yz.core.models import MetaInfoModel

from .managers import CategoryManager
from .managers import ProductManager
from .managers import ProductCategoryRelationManager
from .managers import PropertyManager
from .managers import ProductPropertyRelationManager
from .managers import ProductPropertyValueManager
from .managers import ProductImageManager
from . import settings

get_uuid = lambda: str(uuid.uuid4())

def get_last_position(model_instance):
    try:
        last = model_instance.__class__.objects.order_by('-position')[0].position + 10
    except IndexError:
        last = 10
    return last


class PriceField(models.DecimalField):
    """
    The price field for models which use prices
    """
    def __init__(self, *args, **kwargs):
        kwargs.update(dict(
            default=0,
            max_digits=settings.PRICE_DECIMAL_DIGITS,
            decimal_places=settings.PRICE_DECIMAL_PLACES
        ))
        super(PriceField, self).__init__(*args, **kwargs)


class OverrideFormField(forms.BooleanField):
    """ A special form field for overriding product's properties """
    pass

class OverrideField(models.BooleanField):
    """ A special model field for overriding product's properties """
    override_fields = None

    def __init__(self, *args, **kwargs):
        """
        Setup
        """
        self.override_fields = kwargs.pop('override_fields', None)
        defaults = {
            'default': False,
        }
        defaults.update(kwargs)
        super(OverrideField, self).__init__(*args, **defaults)

    def formfield(self, **kwargs):
        defaults = {'form_class': OverrideFormField}
        defaults.update(kwargs)
        return super(OverrideField, self).formfield(**defaults)

class Manufacturer(models.Model):
    """
    Manufacturer
    """
    name = models.CharField(_(u"title"), max_length=100)
    country = models.ForeignKey("core.Country", verbose_name=_(u"country"),
            blank=True, null=True, related_name="+")
    image = ThumbnailerImageField(_(u"image"), upload_to="images/manufacturers", blank=True, null=True)

    class Meta:
        ordering = ("name", )
        verbose_name = _(u'manufacturer')
        verbose_name_plural = _(u'manufacturers')


    def __unicode__(self):
        return "%s (%s)" % (self.name, self.country.name)

class Category(MetaInfoModel):
    """
    Category model with tree-like structure
    """
    name = models.CharField(_(u"title"), max_length=100)
    slug = models.SlugField(_(u"slug"), max_length=100, unique=True)
    parent = models.ForeignKey("self", verbose_name=_(u"parent"),
            blank=True, null=True, related_name="children")
    short_description = models.TextField(_(u"short description"), blank=True)
    description = models.TextField(_(u"description"), blank=True)
    image = ThumbnailerImageField(_(u"image"), upload_to="images/categories", blank=True, null=True)

    position = models.IntegerField(_(u"position"), default=0)
    active = models.BooleanField(_(u"active"), db_index=True, default=False)

    static_block = models.ForeignKey("core.StaticBlock", verbose_name=_(u"static block"),
            blank=True, null=True, related_name="+")

    uid = models.CharField(_(u"UUID"), help_text=_(u"Universally unique product ID"),
            default=get_uuid,
            max_length=50)

    objects = CategoryManager()

    class Meta:
        ordering = settings.CATEGORIES_ORDERING
        verbose_name = _(u'category')
        verbose_name_plural = _(u'categories')

    def __unicode__(self):
        return "%s (%s)" % (self.name, self.slug)

    @models.permalink
    def get_absolute_url(self):
        """
        Returns the absolute_url.
        """
        return ("yz_catalog_category", (), {"slug": self.slug})

    @classmethod
    def get_top_categories(cls, active=True):
        """
        Get the (cached) list of top-level categories
        """
        return cls.objects.get_top_categories(active=active)


    def get_children(self, active=True):
        """
        Get the category's children, by default filter out inactive
        Else lookup cached
        """
        return Category.objects.get_children(self, active=active)

    def get_all_subcategories(self, active=True):
        """
        Get the category's subtree, by default filter out inactive
        """
        return Category.objects.get_all_subcategories(self, active=active)

    def get_ancestors(self):
        """
        Get all ancestors of the category, including itself
        """
        return Category.objects.get_ancestors(self)

    def get_products(self, active=True, sorting=None, filters=None):
        """
        Get products belonging to the category
        TODO use the sorting and filters
        """
        return Product.objects.get_products_for_category(self,
                filters=filters,
                sorting=sorting,
                active=active)

    def get_active_products(self, sorting=None, filters=None):
        return self.get_products(active=True, sorting=sorting, filters=filters)


    def get_all_products(self, active=True):
        """
        Get the list of all products (or their IDs if ids_only) which are in
            the category and its subcategories
        """
        product_set = Product.objects.get_products_in_category(self,
                deep=True, active=active)
        return product_set


    def get_all_active_products(self):
        return self.get_all_products(active=True)


    def get_manufacturers(self):
        product_ids = self.get_all_products(active=True, ids_only=True)
        return Manufacturer.objects.filter(products__in=product_ids).distinct()


class Product(MetaInfoModel):
    """
    Base product class

    """
    UNITS_PIECE = "piece"
    UNITS_PACKAGE = "package"
    UNITS_PAIR = "pair" # e.g. gloves, socks
    UNITS_SET = "set"
    UNITS_LITER = "l"
    UNITS_METER = "m"
    UNITS_CENTIMETER = "cm"
    UNITS_SQ_METER = "sq.m"
    UNITS_CU_METER = "cu.m"
    UNITS_GRAM = "g"
    UNITS_KILOGRAM = "kg"
    UNITS = (
        (UNITS_PIECE, _(u"piece")),
        (UNITS_PACKAGE, _(u"package")),
        (UNITS_PAIR, _(u"pair")),
        (UNITS_SET, _(u"set")),
        (UNITS_LITER, _(u"l")),
        (UNITS_METER, _(u"m")),
        (UNITS_SQ_METER, _(u"sq.m")),
        (UNITS_CU_METER, _(u"cu.m")),
        (UNITS_GRAM, _(u"g")),
        (UNITS_KILOGRAM, _(u"kg")),
        (UNITS_CENTIMETER, _(u"cm")),
    )

    LENGTH_UNITS = (
        ("m", _(u"m")),
        ("cm", _(u"cm")),
        ("mm", _(u"mm")),
    )
    WEIGHT_UNITS = (
        ("kg", _(u"kg")),
        ("g", _(u"g")),
    )


    # product name is not necessarily unique
    name = models.CharField(_(u"title"), max_length=200)
    # slug is always unique
    slug = models.SlugField(_(u"slug"), max_length=250, unique=True)
    uid = models.CharField(_(u"UUID"), help_text=_(u"Universally unique product ID"),
            default=get_uuid,
            unique=True,
            max_length=50)
    # the base product (when the product is a variant)
    parent = models.ForeignKey('self', verbose_name=_(u"product"),
            related_name="variants", blank=True, null=True)

    short_description = models.TextField(_(u"short description"), blank=True)
    short_description_override = OverrideField(_(u'short_description'), default=False)
    description = models.TextField(_(u"description"), blank=True)
    description_override = OverrideField(_(u'description'), default=False)

    position = models.IntegerField(_(u"position"), db_index=True, default=0)
    active = models.BooleanField(_(u"active"), db_index=True, default=False,
                                help_text=_("whether the product is visible"))

    categories = models.ManyToManyField(Category, verbose_name=_(u"categories"), blank=True,
            through="ProductCategoryRelation",
            related_name="products")
    categories_override = OverrideField(_(u'categories'), default=False)

    manufacturer = models.ForeignKey(Manufacturer, verbose_name=_(u"manufacturer"),
            blank=True, null=True, related_name="products")
    manufacturer_override = OverrideField(_(u'manufacturer'), default=False)

    # the properties unique for given product / variant
    sku = models.CharField(_(u"SKU"), help_text=_(u"Your unique product article number"),
            max_length=50, blank=True, null=True, unique=True)
    original_sku = models.CharField(_(u"original SKU"), help_text=_(u"Manufacturer's product article number"),
            blank=True, null=True, max_length=50)
    barcode = models.DecimalField(_(u"bar code"), help_text=_(u"EAN-13 or similar bar code"),
            blank=True, null=True, max_digits=20, decimal_places=0)

    # package units
    units = models.CharField(_(u"quantity units"), max_length=20, choices=UNITS, default=UNITS_PIECE)
    units_override = OverrideField(_(u'units'), default=False)
    # quantity of items in the product's package measured in package units
    quantity = models.DecimalField(_(u"quantity"), help_text=_(u'quantity per stock unit'),
                                   max_digits=10, decimal_places=3, default=1)
    quantity_override = OverrideField(_(u'quantity'), default=False)

    # price per stock unit (e.g. for a 6-bottle box, the price per box not per each bottle)
    price = PriceField(_(u"price"), help_text=_(u'price per stock unit'))
    price_override = OverrideField(_(u'price'), default=False)

    on_sale = models.BooleanField(_(u"on sale"), default=False)
    on_sale_override = OverrideField(_(u'on sale'), default=False)
    sale_price = PriceField(_(u"sale price"))
    sale_price_override = OverrideField(_(u'sale price'), default=False)

    # the price used to sort/filter, calculated as
    # real_sale_price if real_on_sale else real_price
    effective_price = PriceField(_(u"effective price"), editable=False)

    available = models.BooleanField(_(u"available for ordering"), default=True)
    available_override = OverrideField(_(u'available for ordering'), default=False)
    available_date = models.DateField(_(u"when becomes available for ordering"), blank=True, null=True)
    available_date_override = OverrideField(_(u'when becomes available for ordering'), default=False)

    length = models.DecimalField(_(u"length"), max_digits=10, decimal_places=3, default=0)
    length_override = OverrideField(_(u'length'), default=False)
    width  = models.DecimalField(_(u"width"),  max_digits=10, decimal_places=3, default=0)
    width_override = OverrideField(_(u'width'), default=False)
    height = models.DecimalField(_(u"height"), max_digits=10, decimal_places=3, default=0)
    height_override = OverrideField(_(u'height'), default=False)
    weight = models.DecimalField(_(u"weight"), max_digits=10, decimal_places=3, default=0)
    weight_override = OverrideField(_(u'weight'), default=False)

    length_units = models.CharField(_(u"length units"), max_length=3, choices=LENGTH_UNITS, default="mm")
    length_units_override = OverrideField(_(u'length units'), default=False)
    weight_units = models.CharField(_(u"weight units"), max_length=3, choices=WEIGHT_UNITS, default="g")
    weight_units_override = OverrideField(_(u'weight units'), default=False)

    properties = models.ManyToManyField("Property", verbose_name=_(u"properties"),
            blank=True,
            through="ProductPropertyRelation",
            related_name="products")

    images_override = OverrideField(_(u'images'), default=False)

    # default manager
    objects = ProductManager()


    class Meta:
        ordering = settings.PRODUCTS_ORDERING
        verbose_name = _(u'product')
        verbose_name_plural = _(u'products')

    def __unicode__(self):
        return "%s (%s)" % (self.name, self.sku)


    def __getitem__(self, key):
        """ Get the 'real' value of attribute
            i.e. taking into account the 'override' suffix if it exists
        """
        try:
            val = getattr(self, key)
        except AttributeError:
            raise KeyError("Key '{}' does not exist".format(key))

        if self.is_variant():
            # if override is not defined,
            # by default, take the value from self -- i.e. override is True
            override = getattr(self, "{}_override".format(key), True)
            if not override:
                val = getattr(self.parent, key)
        return val


    def __setitem__(self, key, value):
        """ Set the 'real' value of attribute
            if 'override' exists and is False (not allowed), raise ValueError
        """
        if not hasattr(self, key):
            raise KeyError("Key '{}' does not exist".format(key))
        if self.is_variant():
            override = getattr(self, "{}_override".format(key), True)
            if not override:
                raise ValueError("Can not set '{}' because override is not allowed".format(key))
            setattr(self, key, value)


    @models.permalink
    def get_absolute_url(self):
        """
        Get the absolute url of the product.
        """
        return ("yz_catalog_product", (), {"slug": self.slug})

    def get_parent(self):
        if not self.is_variant():
            return None
        return self.__class__.objects.get_cached(id=self.parent_id)


    def is_variant(self):
        "Whether the product is a variant of another product"
        return settings.VARIANTS_ENABLED and self.parent_id > 0

    def is_base_product(self):
        "Whether the product is a variant of another product"
        return settings.VARIANTS_ENABLED and not self.parent_id

    def get_variants(self, active=None):
        """
        Get the product's variants
        """
        if self.is_variant():
            prod = self.get_parent()
        else:
            prod = self
        variants = Product.objects.get_variants(prod, active)
        return variants

    def get_active_variants(self):
        """
        Get the product's active variants
        """
        return self.get_variants(active=True)


    def get_default_variant(self):
        """ Get Default variant which is either self or the first active variant
        """
        if not settings.VARIANTS_ENABLED:
            return self
        if self.is_variant():
            return self.get_parent().get_default_variant()
        try:
            return self.get_active_variants()[0]
        except IndexError:
            return self


    def get_categories(self):
        """ Get a cached list of categories the product belongs to """
        prod = self
        if self.is_variant() and not self.categories_override:
            prod = self.get_parent()
        #cat_ids = ProductCategoryRelation.objects.get_categories_for_product(self)
        #return Category.objects.get_categories_by_ids(cat_ids)
        return Category.objects.get_categories_for_product(prod)


    def get_category(self, id=None, slug=None):
        " TODO: Category relation w/position "
        my_cats = self.get_categories()
        if id is not None:
            # search by id
            for cat in my_cats:
                if cat.id == id:
                    return cat
        if slug is not None:
            # search by slug
            for cat in my_cats:
                if cat.slug == slug:
                    return cat
        if id is not None and slug is not None:
            # product has no such category
            raise Product.DoesNotExist
        if my_cats:
            return my_cats[0]
        return None


    def get_images(self):
        """
        Get the list of product's images from cache
        """
        prod = self
        if self.is_variant() and not self.images_override:
            prod = self.get_parent()
        return ProductImage.objects.get_images_for_product(prod)


    def get_image(self):
        """
        Get the product's main image from cache
        """
        try:
            return self.get_images()[0]
        except IndexError:
            return None


    def save(self, *args, **kwargs):
        """
        Automatically force active=False if both prices are effectively 0
        """
        if self.sale_price < 0:
            self.sale_price = 0
        if self.price < 0:
            self.price = 0
        self.effective_price = self.sale_price if self.on_sale else self.price
        if self.effective_price == 0:
            self.active = False

        #if not self.position:
        #    self.position = get_last_position(self)
        super(Product, self).save(*args, **kwargs)
        if not self.sku and not self.is_base_product():
            # for base products, it's OK to have no SKU
            # we could use:
            # self.sku = self.original_sku or self.barcode or self.uid
            # but we can't rely on the two fields being unique
            self.sku = self.id
            super(Product, self).save(*args, **kwargs)

    def get_properties(self):
        """Get the list of Property objects for all defined properties """
        prod = self
        if self.is_variant():
            prod = self.get_parent()
        return Property.objects.get_properties_for_product(prod)


    def get_property_value(self, property):
        """
        Get the value of a property from cache
        property can be a string (slug) as well as Property instance
        returns the matching property_value object or a list of those
        """
        if not isinstance(property, Property):
            try:
                property = Property.objects.get(slug=property)
            except Property.DoesNotExist:
                return None
        val = ProductPropertyValue.objects.get_property_values(property, self)
        if not val:
            return None
        else:
            if len(val) == 1:
                return val[0]
            return val[:]

    def get_property_values(self):
        """
        Get the list of variant's property values from cache
        """
        return ProductPropertyValue.objects.get_all_properties_values(self)

    def copy(self, **variant_data):
        """
        Copy a variant as a copy of instance, excluding important unique fields
        raises kinda UniqueError
        """
        v = Product(**variant_data)
        for f in ('description',
                'quantity', 'price', 'on_sale', 'effective_price',
                'length', 'width', 'height', 'weight',
        ):
            if f not in variant_data:
                setattr(v, f, getattr(self, f))
        v.save()
        for pv in self.property_values.all():
            pv = pv.copy(product=v)
        return v


class ProductVariant(object):
        pass


class ProductCategoryRelation(models.Model):
    """
    ProductCategoryRelation defines which categories are assigned to products
        and to their variants if categories_override is off, and controls the order of displaying
        the categories for a product
    """
    product = models.ForeignKey(Product, verbose_name=_(u"product"),
            related_name="categories_relation")
    category = models.ForeignKey(Category, verbose_name=_(u"category"),
            related_name="products_relation")
    position = models.IntegerField(_(u"position"), default=0, db_index=True)

    objects = ProductCategoryRelationManager()

    class Meta:
        ordering = ('position', )
        unique_together = ("product", "category")
        verbose_name = _('Product to Category Relation')
        verbose_name_plural = _('Product to Category Relations')

    def __unicode__(self):
        return "%s:%s(%s)" % (self.product.name, self.category.name, self.position)

    #def save(self, *args, **kwargs):
        #super(ProductCategoryRelation, self).save(*args, **kwargs)
        #m2m_changed.send(sender=Product, instance=self.product, )


class Property(models.Model):
    """
    Property is a multi-purpose class
    The possible uses of Property are: (e.g. for a laptop)
        - product "has property N" (boolean): e.g. LED backlight
        - product has a variant with property N: e.g.
        - product's property N equals ... (or is comparable to ...)
        - set product's property N to ...
    Possible value types are (not limited to):
        - boolean
        - integer
        - option
    """
    VALUE_TYPE_BOOLEAN = "boolean"
    VALUE_TYPE_INTEGER = "integer"
    VALUE_TYPE_DECIMAL = "decimal"
    VALUE_TYPE_OPTION  = "option"
    VALUE_TYPE_CHOICES = (
        (VALUE_TYPE_BOOLEAN, _(u"boolean")),
        (VALUE_TYPE_INTEGER, _(u"integer")),
        (VALUE_TYPE_DECIMAL, _(u"decimal")),
        (VALUE_TYPE_OPTION,  _(u"option")),
    )


    name = models.CharField(_(u"title"), max_length=100)
    slug = models.SlugField(_(u"slug"), max_length=100)
    value_type = models.CharField(_(u"value type"), max_length=10, choices=VALUE_TYPE_CHOICES)
    is_multivalue = models.BooleanField(_(u'allow multiple values'), default=False)

    objects = PropertyManager()

    class Meta:
        ordering = ("name", )
        verbose_name = _(u'property')
        verbose_name_plural = _(u'properties')

    def __unicode__(self):
        return self.name
        return "%s(%s)" % (self.name, self.value_type)

    def get_value_for_product(self, product):
        try:
            val = self.property_values.get(product=product)
        except ProductPropertyValue.DoesNotExist:
            val = None
        else:
            val = val.get_value()
        return val

    @property
    def value_field_name(self):
        """
        The field name to use to access the value of ProductPropertyValue instance
        """
        return "value_%s" % self.value_type

    @property
    def is_option(self):
        return self.value_type == Property.VALUE_TYPE_OPTION



class PropertyOption(models.Model):
    """
    PropertyOption represents textual options
    NOTE: TODO: when saved, update all property_values which use that option
    """
    property = models.ForeignKey(Property, verbose_name=_(u"property"),
            related_name="options")
    value = models.CharField(_(u"value"), max_length=100)

    class Meta:
        ordering = ('value', )
        verbose_name = _(u'property option')
        verbose_name_plural = _(u'property options')

    def __unicode__(self):
        return self.value
        return "%s: %s" % (self.property.name, self.value)


class ProductPropertyRelation(models.Model):
    """
    ProductPropertyRelation defines which properties are assigned to products
        and must be assigned to their variants, and controls the order of displaying
        the properties
    """
    product = models.ForeignKey(Product, verbose_name=_(u"product"),
            related_name="properties_relation")
    property = models.ForeignKey(Property, verbose_name=_(u"property"),
            related_name="products_relation")
    position = models.IntegerField(_(u"position"), default=10, db_index=True)

    objects = ProductPropertyRelationManager()

    class Meta:
        ordering = ('position', )
        unique_together = ("product", "property")
        verbose_name = _('Product to Property Relation')
        verbose_name_plural = _('Product to Property Relations')

    def __unicode__(self):
        return "%s:%s(%s)" % (self.product.name, self.property.name, self.position)


    def delete(self, *args, **kwargs):
        """
        Automatically delete property values for
            the product's variants
        """
        variants = self.product.get_variants()
        property_values = ProductPropertyValue.objects.filter(product__in=variants,
                property=self.property)
        for pv in property_values:
            pv.delete() # ensure model's delete() ???
        super(ProductPropertyRelation, self).delete(*args, **kwargs)


class ProductPropertyValue(models.Model):
    """
    ProductPropertyValue is a relation of product_variants to property values
    """
    _property_decorator = property # for later use

    # Fields
    product = models.ForeignKey(Product, verbose_name=_(u"product"),
            related_name="property_values")
    property = models.ForeignKey(Property, verbose_name=_(u"property"),
            related_name="property_values")
    #value = models.CharField(_(u"value"), max_length=100, editable=False)
    value_option = models.ForeignKey(PropertyOption, verbose_name=_(u"property option"),
            related_name="property_values", blank=True, null=True)
    value_integer = models.IntegerField(_(u"integer value"), blank=True, null=True, db_index=True)
    value_decimal = models.DecimalField(_(u"decimal value"), blank=True, null=True, db_index=True,
            decimal_places=5, max_digits=15)
    value_boolean = models.NullBooleanField(_(u"boolean value"), db_index=True)

    objects = ProductPropertyValueManager()

    class Meta:
        #unique_together = ("product", "property")
        verbose_name = "property value"

    def __unicode__(self):
        return "%s: %s=%s" % (self.product.name, self.property.name, self.value)

    def __nonzero__(self):
        v = self.get_value()
        return not (v is None or v == "")


    def get_value(self):
        """
        Get the real value
        NOTE: a textual value is available even for an Option when cast to string
        """
        return getattr(self, self.property.value_field_name)

    def set_value(self, value):
        attr = self.property.value_field_name
        setattr(self, attr, value)

    value = _property_decorator(get_value, set_value)


    def copy(self, **values):
        """
        Create new ProductPropertyValue as a copy of the instance
        """
        pv = ProductPropertyValue(**values)
        for field in self._meta.local_fields:
            f = field.name
            if f not in values:
                setattr(pv, f, getattr(self, f))
        pv.save()
        return pv


class ProductImage(models.Model):
    """
    """
    product = models.ForeignKey(Product, verbose_name=_(u"product"),
            related_name="images")
    image = ThumbnailerImageField(_(u"image"), upload_to="images/products", )
    position = models.IntegerField(_(u"position"), default=100)
    title = models.CharField(_(u"title"), max_length=200, blank=True)

    objects = ProductImageManager()

    class Meta:
        ordering = ('position', )

